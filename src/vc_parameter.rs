use ark_bls12_381::fr::Fr;
use ark_bls12_381::G1Projective as G1;
use ark_bls12_381::G2Projective as G2;
use ark_ec::Group;
use ark_ff::Field;
use ark_serialize::CanonicalDeserialize;
use ark_serialize::CanonicalSerialize;
use ark_std::rand::Rng;
use ark_std::UniformRand;

/// Parameters in VC generated by trusted third party
#[derive(Clone, CanonicalSerialize, CanonicalDeserialize)]
pub struct VcParameter {
    pub n: usize,
    pub logn: usize,
    /// [s^0]_1, [s^1]_1, ..., [s^n]_1
    pub gs1: Vec<G1>,
    /// [s^0]_2, [s^1]_2, ..., [s^n]_2
    pub gs2: Vec<G2>,
}

impl VcParameter {
    pub fn new<R: Rng + ?Sized>(logn: usize, rng: &mut R) -> (Fr, VcParameter) {
        let n = 1 << logn;
        // trapdoor s
        let s: Fr = Fr::rand(rng);
        let s_powers: Vec<Fr> = std::iter::successors(Some(Fr::ONE), |&prev| Some(prev * s))
            .take(n)
            .collect();
        let gs1: Vec<G1> = s_powers.iter().map(|&sp| G1::generator() * sp).collect();
        let gs2: Vec<G2> = s_powers.iter().map(|&sp| G2::generator() * sp).collect();
        (s, VcParameter { n, logn, gs1, gs2 })
    }
}

//#[cfg(test)]
pub mod tests {
    use super::*;

    pub fn test_parameter(logn: usize) -> (Fr, VcParameter) {
        let mut rng = ark_std::test_rng();
        VcParameter::new(logn, &mut rng)
    }
}
